## Pseudocode of convertion between dec and hex
(1) Pseudocode
```
READ NumberinDecimal
IF NumberinDecimal \< 0 THEN
    PRINT "-"
    SET NumberinDecimal to the Absolute value
ENDIF
SET DigitCount to 0
REPEAT
    INCREASE DigitCount by 1
    COMPUTE CurrentDigit as NumberinDecimal mod 16
    IF CurrentDigit \>= 0 and Current Digit \<= 9 THEN
        NumberinHex[DigitCount] = CurrentDigit
    ELSE
        CASE CurrentDigit OF
            10  : NumberinHex[DigitCount] = "A"
            11  : NumberinHex[DigitCount] = "B"
            12  : NumberinHex[DigitCount] = "C"
            13  : NumberinHex[DigitCount] = "D"
            14  : NumberinHex[DigitCount] = "E"
            15  : NumberinHex[DigitCount] = "F"
        ENDCASE
    ENDIF
    DIVIDE NumberinDecimal by 16
UNTIL Number in Decimal = 0
FOR DigitPosition = DigitCount to 1
    PRINT NumberinHex[DigitPosition]
ENDFOR
```
(2) C code
```C
#include<stdio.h>

int main()
{
    int number_to_convert;
    char number_in_hex[9];
    //READ NumberinDecimal
    scanf("%d", &number_to_convert);
    //IF NumberinDecimal < 0 THEN
    if (number_to_convert < 0)
    {
        //PRINT "-"
        printf("-");
        //SET NumberinDecimal to the Absolute value
        number_to_convert = -number_to_convert;
    }
    //ENDIF
    //SET DigitCount to 0
    int count_of_digits = 0;
    //REPEAT
    do 
    {
        //INCREASE DigitCount by 1
        count_of_digits++;
        //COMPUTE CurrentDigit as NumberinDecimal mod 16
        int current_digit = number_to_convert % 16;
        //IF CurrentDigit >= 0 and Current Digit <= 9 THEN
        if (current_digit >= 0 && current_digit <= 9)
            //NumberinHex[DigitCount] = CurrentDigit
            number_in_hex[count_of_digits] = '0' + current_digit;
        //ELSE
        else
            /*
            CASE CurrentDigit OF
                10  : NumberinHex[DigitCount] = "A"
                11 : NumberinHex[DigitCount] = "B"
                12 : NumberinHex[DigitCount] = "C"
                13 : NumberinHex[DigitCount] = "D"
                14 : NumberinHex[DigitCount] = "E"
                15 : NumberinHex[DigitCount] = "F"
            ENDCASE
            */
            number_in_hex[count_of_digits] = 'A' + current_digit - 10;
        //ENDIF
        //DIVIDE NumberinDecimal by 16
        number_to_convert /= 16;
    } while (number_to_convert != 0); //UNTIL Number in Decimal = 0
    //FOR DigitPosition = DigitCount to 1
    for (int i = count_of_digits; i >= 1; --i)
        //PRINT NumberinHex[DigitPosition]
        printf("%c", number_in_hex[i]);
    //ENDFOR
}
```
(3)Test<br>
-1=-0x1, 0=0x0, 1=0x1, 15=0xF, 26=0x1A, 3265=0xCC1

## Definition and Comparison
1. **Top-down design** 
A top-down approach (also known as stepwise design and in some cases used as a synonym of decomposition) is essentially the breaking down of a system to gain insight into its compositional sub-systems in a reverse engineering fashion.<br>
自顶向下方法（也被认为是阶梯式设计并且有些情况下被用作分治的同义词）是一种本质上以一种反向的工程方式将一个系统分解来获得对构成其的子系统的了解。
2. **Work breakdown structure**
A work-breakdown structure in project management and systems engineering, is a deliverable-oriented breakdown of a project into smaller components.<br>
项目管理和系统工程中的工作分解结构，是一种以交付为目的分解方法，将一个项目细分成更小的组成部分。
3. **Comparsion**
二者的相同点在于都使用了分解的方法，将大的项目或者问题进行分解之后逐个解决，不同点在于自顶向下方法面向的更多的是一个单一的问题，将问题分解的目的是将大问题转化为能更快地解决的小问题，而这些小问题之间有可能会有一定的相似性；工作分解结构面向的更多的是一个大型的项目，将其分解的目的是将整个项目中具有不同目的的部分分开，从而使用不同的方法针对性的完成各个子项目，实现高效率的完成和快速的交付。

## 洗衣机
#### 1. 正常洗衣基本程序
* 加水
* 浸泡
* 漂洗
* 放水
* 甩干
* 重复上述5步多次
* 停机
#### 2. 程序伪代码
1. **加水**
```
water_in_switch(open)
SET Max_Water_Volume to 50
WHILE get_water_volume() != Max_Water_Volume
    time_counter()
water_in_switch(close)
```
2. **浸泡**
```
SET Start_Time to time_counter()
SET Wait_Time to 1200
REPEAT
    SET End_Time to time_counter()
UNTIL End_Time - Start_Time = Wait_Time
```
3. **漂洗**
```
SET Max_Wash_Times to 10
SET Max_Wash_Circles to 10
FOR Wash_Times = 1 to Max_Wash_Times
    FOR Circle_Times = 1 to Max_Wash_Circles
        motor_run(left)
        motor_run(stop)
        motor_run(right)
        motor_run(stop)
```
4. **放水**
```
water_out_switch(open)
SET Min_Water_Volume to 0
WHILE get_water_volume() != Min_Water_Volume
    time_counter()
water_out_switch(close)
```
5. **甩干**
```
SET Max_Drying_Times to 5
SET Max_Drying_Circles to 10
FOR Wash_Times = 1 to Max_Drying_Times
    FOR Circle_Times = 1 to Max_Drying_Circles
        motor_run(left)
        motor_run(stop)
    FOR Circle_Times = 1 to Max_Drying_Circles
        motor_run(right)
        motor_run(stop)
```

water_in_switch(open_close)  // open 打开上水开关，close关闭
water_out_switch(open_close)  // open 打开排水开关，close关闭
get_water_volume()  //返回洗衣机内部水的高度
motor_run(direction) // 电机转动。left左转，right右转，stop停
time_counter()  // 返回当前时间计数，以秒为单位
halt(returncode) //停机，success 成功 failure 失败

#### 3. 正常洗衣和快速洗衣的差别

正常洗衣针对的是衣服较多，需要完整洗衣流程的人群，快速洗衣更多针对于衣服较少或者只需要洗衣机完成部分洗衣程序的人群。<br>
快速洗衣虽然使用的步骤和流程与正常洗衣相同，但是用水相对较少，同时漂洗和甩干的用时相对较少，漂洗时电机转动速度相对较高，加水漂洗放水甩干等步骤的重复次数更少。<br>
可以将大部分洗衣步骤概括成一个模块，同时该模块包含最大水量，电机转速，重复次数等参数，通过调节这些参数可以实现快速洗衣和正常洗衣甚至是更多其他模式。

#### 4. 功能模块

1. **等待一定时间**
```
SUBPROCEDURES wait(Timeout)
    SET Start_Time to time_counter()
    SET Wait_Time to Timeout
    REPEAT
        SET End_Time to time_counter()
    UNTIL End_Time - Start_Time = Wait_Time
```
2. **进水**
```
SUBPROCEDURES water_in(Max_Volume, Timeout)
    SET Start_Time to time_counter()
    water_in_switch(open)
    SET Max_Water_Volume to Max_Volume
    WHILE get_water_volume() != Max_Volume and End_Time - Start_Time != Wait_Time
        SET End_Time to time_counter()
    water_in_switch(close)
```
3. **放水**
```
SUBPROCEDURES water_out(Min_Volume, Timeout)
    SET Start_Time to time_counter()
    water_out_switch(open)
    WHILE get_water_volume() != Min_Volume and End_Time - Start_Time != Wait_Time
        SET End_Time to time_counter()
    water_out_switch(close)
```